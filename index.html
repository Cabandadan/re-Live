<!DOCTYPE html>
<html>
<head>
  <style>
  body {
  margin: 0;
  padding: 0;
  }

  #container {
    position: fixed;
    touch-action: none;
  }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
  <script id="vertexShader" type="x-shader/x-vertex">
      void main() {
          gl_Position = vec4( position, 1.0 );
      }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec2 u_resolution;
    uniform vec4 u_mouse;
    uniform float u_time;
    uniform sampler2D u_noise;
    uniform sampler2D u_buffer;
    uniform bool u_renderpass;
    uniform int u_frame;

    #define PI 3.141592653589793
    #define TAU 6.283185307179586

    vec2 hash2(vec2 p)
    {
      vec2 o = texture2D( u_noise, (p+0.5)/256.0, -100.0 ).xy;
      return o;
    }

    vec3 hsb2rgb( in vec3 c ){
      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                               6.0)-3.0)-1.0,
                       0.0,
                       1.0 );
      rgb = rgb*rgb*(3.0-2.0*rgb);
      return c.z * mix( vec3(1.0), rgb, c.y);
    }

    vec3 domain(vec2 z){
      return vec3(hsb2rgb(vec3(atan(z.y,z.x)/TAU,1.,1.)));
    }
    vec3 colour(vec2 z) {
        return domain(z);
    }

    // Shorthand, so that the texture lines read a little better.
    // Borrowed from Shane
    vec4 tx(vec2 p){ return texture2D(u_buffer, p); }

    // 25 (or 9) tap Laplacian -- Gaussian Laplacian, to be more precise. I think of it as taking
    // the sum of the partial second derivatives of a blurry 2D height map... in each channel...
    // I think I'm making things more confusing, but it works anyway. :D Seriously, just look
    // up the Laplacian operator of a 2D function.
    // Borrowed from Shane
    vec4 Laplacian(vec2 p) {

      // Kernel matrix dimension, and a half dimension calculation.
      const int mDim = 5, halfDim = (mDim - 1)/2;

  //     float scale = .25;
  //     float kernel[25];
  //     kernel[0] = 1. * scale;
  //     kernel[1] = 1. * scale;
  //     kernel[2] = 1. * scale;
  //     kernel[3] = 1. * scale;
  //     kernel[4] = 1. * scale;

  //     kernel[5] = 1. * scale;
  //     kernel[6] = 1. * scale;
  //     kernel[7] = 1. * scale;
  //     kernel[8] = 1. * scale;
  //     kernel[9] = 1. * scale;

  //     kernel[10] = 1. * scale;
  //     kernel[11] = 1. * scale;
  //     kernel[12] = -24. * scale;
  //     kernel[13] = 1. * scale;
  //     kernel[14] = 1. * scale;

  //     kernel[15] = 1. * scale;
  //     kernel[16] = 1. * scale;
  //     kernel[17] = 1. * scale;
  //     kernel[18] = 1. * scale;
  //     kernel[19] = 1. * scale;

  //     kernel[20] = 1. * scale;
  //     kernel[21] = 1. * scale;
  //     kernel[22] = 1. * scale;
  //     kernel[23] = 1. * scale;
  //     kernel[24] = 1. * scale;



      float kernel[25];
      kernel[0] = 0.;
      kernel[1] = 0.;
      kernel[2] = 0.25;
      kernel[3] = 0.;
      kernel[4] = 0.;

      kernel[5] = 0.;
      kernel[6] = 0.25;
      kernel[7] = 0.50;
      kernel[8] = 0.25;
      kernel[9] = 0.;

      kernel[10] = 0.25;
      kernel[11] = 0.50;
      kernel[12] = -4.0;
      kernel[13] = 0.50;
      kernel[14] = 0.25;

      kernel[15] = 0.;
      kernel[16] = 0.25;
      kernel[17] = 0.50;
      kernel[18] = 0.25;
      kernel[19] = 0.;

      kernel[20] = 0.;
      kernel[21] = 0.;
      kernel[22] = 0.25;
      kernel[23] = 0.;
      kernel[24] = 0.;

      vec4 col = vec4(0);

      float px = 1./u_resolution.y;

      for (int j=0; j<mDim; j++){
        for (int i=0; i<mDim; i++){
          col += kernel[j*mDim + i]*tx(p + vec2(i - halfDim, j - halfDim)*px);
        }
      }

      return col;
    }


    void mainImage( out vec4 fragColor, in vec2 fragCoord ){

      vec2 p = fragCoord.xy/u_resolution.xy;

      vec4 rdVal = texture2D(u_buffer, p);

      vec2 lap = Laplacian(p).xy;

      float mixamt = clamp(length(p-.5) * 2., 0., 1.);

      float feed = 0.03867;
      float kill = 0.06149;

      vec2 dAB = vec2(.22685, .08405);

      const float t = 1.5;

      vec2 diffusion = dAB*lap;

      vec2 reaction = vec2(rdVal.x*rdVal.y*rdVal.y)*vec2(-1, 1);

      vec2 feedKill = vec2(feed*(1. - rdVal.x), (kill + feed)*rdVal.y)*vec2(1, -1);
      vec2 delta = diffusion + reaction + feedKill;

      fragColor.xy = clamp(rdVal.xy + delta*t, 0., 1.);

      fragColor.zw = u_resolution.xy;

      if( u_frame<3 ) {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);
        uv *= 3.;
        vec2 ids = floor(uv);
        uv.x += .5 * ids.y;
        uv = fract(uv);
        float shade = smoothstep(.3, .2, length(uv-.5));
        fragColor.y = shade;
        fragColor.x = 1.-shade;
        // float shade = step(p.y, .7) * step(p.x, .7) * step(.3, p.y) * step(.3, p.x);
        // shade = smoothstep(1., .6, p.y) * smoothstep(1., .6, p.x) * smoothstep(-0., .4, p.y) * smoothstep(-0., .4, p.x);
        // shade = clamp(shade, 0., 1.);
        // shade = 1. - shade;
        // fragColor.xy = vec2(shade);
        // fragColor.xy += texture2D(u_noise, uv * .1).rg;
        // fragColor.xy *= fragColor.xy*fragColor.xy*fragColor.xy*fragColor.xy*fragColor.xy*10.;
      }
    }
    void main() {
      vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);

      vec2 mouse = u_mouse.xy - uv;

      float shade = smoothstep(.1, .15, length(mouse));

      vec4 fragcolour = vec4(shade);

      if(u_mouse.z == 1.) {
        fragcolour = vec4(shade, 0., 0., 0.);
      } else if(u_mouse.a == 1.) {
        fragcolour = vec4(0., shade, 0., 0.);
      }

      // vec3 fragcolour = colour(uv);

      if(u_renderpass == true) {
        mainImage( gl_FragColor, gl_FragCoord.xy );
      } else {
        uv*=.8;
        // uv += 1.;
        // gl_FragColor = vec4(smoothstep(0.25, 0.05, texture2D(u_buffer, (uv - 1.5 + vec2(u_time*.2, sin(u_time*.2)*.5)) * .5).y));
        float shade1 = smoothstep(0.25, 0.05, texture2D(u_buffer, (uv + u_mouse.xy * 3.) * 1.).y);
        float shade2 = smoothstep(0.25, 0.05, texture2D(u_buffer, (uv + u_mouse.xy * 2.) * 1.5).y);
        float shade3 = smoothstep(0.25, 0.05, texture2D(u_buffer, (uv + u_mouse.xy * 1.) * 2.).y);
        shade1 *= shade1 * shade1;
        gl_FragColor = vec4(mix(0., mix(0., mix(0., 1., 1.-shade3) * .2 + .8, 1.-shade2) * .5 + .5, 1.-shade1));
      }

      // gl_FragColor = fragcolour;
    }
  </script>



  <div id="container" touch-action="none"></div>
  <title>「ｒｅ：Ｌｉｖｅ」</title>
  </head>
</html>
